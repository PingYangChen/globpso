#' Particle Swarm Optimization Algorithms for Minimization Problems
#'
#' Particle Swarm Optimization Algorithms for Minimization Problems
#'
#' @param objFunc The R or Rcpp compiled objective function. See the example.
#' @param lower The vector of finite lower bounds of the search domain.
#' Its length should be equal to the dimension of domain. space.
#' @param upper The vector of finite upper bounds of the search domain.
#' Its length should be equal to the dimension of domain. space.
#' @param PSO_INFO The list of PSO parameters generated by \code{getPSOInfo()}.
#' @param seed The random seed that controls initial swarm of PSO. The default is \code{NULL}.
#' @param verbose The logical value controls if PSO would reports the updating progress. The default is \code{TRUE}.
#' @return An List.
#' \itemize{
#' \item{par}{ the global best particle.}
#' \item{val}{ the objective function value of the global best particle.}
#' \item{history}{ a vector of objective function values of the global best particle in PSO search history.}
#' \item{cputime}{ the computational time in seconds.}
#' }
#' @details
#' TBD
#' @examples
#' library(globpso)
#' # Optimize the 3-dimensional quadratic objective function with location shift
#' objf <- function(x, loc) {
#'   val <- 0
#'   for (i in 1:length(x)) val <- val + (x[i] - loc)^2
#'   return(val)
#' }
#' # The search domain is [-5, 5]^3
#' upp_bound <- rep(5, 3)
#' low_bound <- rep(-5, 3)
#' # Define the location shift to be 1
#' loc_shift <- 1
#' # Run PSO for this optimization problem
#' # Also input the enviorment variable, the location shift 'loc_shift'
#' res <- globpso(objFunc = objf, lower = low_bound, upper = upp_bound, loc = loc_shift)
#' res$par
#' res$val
#' # One can also write C++ objective function to further accelerate the computation
#' library(Rcpp)
#' library(RcppArmadillo)
#' objf_c <- cppFunction('double objf_c(SEXP x, SEXP loc) {
#'     double val = 0;
#'     double loc_c = (double)Rcpp::as<double>(loc);
#'     arma::rowvec x_c = (arma::rowvec)Rcpp::as<arma::rowvec>(x);
#'     for (arma::uword i = 0; i < x_c.n_elem; i++) {
#'       val += (x_c(i) - loc_c)*(x_c(i) - loc_c);
#'     }
#'     return val;
#'   }', depends = "RcppArmadillo")
#' res_c <- globpso(objFunc = objf_c, lower = low_bound, upper = upp_bound, loc = loc_shift)
#' res_c$par
#' res_c$val
#' # Use getPSOInfo() to change the PSO options
#' alg_setting <- getPSOInfo(nSwarm = 64, maxIter = 200, psoType = "quantum")
#' res_c_large <- globpso(objFunc = objf_c, lower = low_bound, upper = upp_bound, PSO_INFO = alg_setting, loc = loc_shift)
#' res_c_large$history
# @references Bonyadi, M. R. and Michalewicz, Z. (2014). A locally convergent rotationally invariant particle swarm optimization algorithm. Swarm Intelligence, 8(3):159-198. 
# @references Cheng, R. and Jin, Y. (2015). A competitive swarm optimizer for large scale optimization. IEEE transactions on cybernetics, 45(2):191-204.
#' @references Shi, Y., & Eberhart, R. (1998, May). A modified particle swarm optimizer. In Evolutionary Computation Proceedings, 1998. IEEE World Congress on Computational Intelligence., The 1998 IEEE International Conference on (pp. 69-73). IEEE.
#' @references Sun, J., Wu, X., Palade, V., Fang, W., Lai, C.-H., and Xu, W. (2012). Convergence analysis and improvements of quantum-behaved particle swarm optimization. Information Sciences, 193:81-103.
#' @name globpso
#' @rdname globpso
#' @export
globpso <- function(objFunc, lower, upper, init = NULL,
	PSO_INFO = NULL, seed = NULL, verbose = TRUE, environment, ...) {

  stopifnot(all(is.finite(lower)), all(is.finite(upper)), 
            length(lower) == length(upper), all(upper > lower)
            )
  hasInitSwarm <- 0
  if (!is.null(init)) {
    if (is.vector(init)) {
      stopifnot(length(lower) == length(init), all(upper >= init), 
                all(is.finite(init)), all(init >= lower))
      init <- matrix(init, 1, length(init))
      hasInitSwarm <- 1
    } else if (is.matrix(init)) {
      for (i in 1:nrow(init)) {
        stopifnot(length(lower) == length(init[i,]), all(upper >= init[i,]), 
                  all(is.finite(init[i,])), all(init[i,] >= lower))
      }
      hasInitSwarm <- 1
    }
  }
  
	if (is.null(PSO_INFO)) {
	  nSwarm <- 32
	  if (hasInitSwarm) { nSwarm = max(32, nrow(init)) }
		PSO_INFO <- getPSOInfo(nSwarm = nSwarm, maxIter = 100)
		if (verbose) message(paste0("Use the default settings for PSO. See '?getPSOInfo'."))
	}
	stopifnot(all(names(PSO_INFO) == names(getPSOInfo())))
	if (hasInitSwarm) { stopifnot(PSO_INFO$nSwarm >= nrow(init)) }
	
	if (!hasArg(environment)) environment <- new.env()

	# Fill the rest of PSO options in PSO_INFO
	PSO_INFO$varUpper <- upper
	PSO_INFO$varLower <- lower
	PSO_INFO$dSwarm <- length(upper)
	PSO_INFO$hasInitSwarm <- hasInitSwarm
	PSO_INFO$initSwarm <- init
	# Start
	set.seed(seed)
	cputime <- system.time(
		psoOut <- cppPSO(objFunc, PSO_INFO, environment, FALSE, verbose)
	)[3]
	if (verbose) message(paste0("CPU time: ", round(cputime, 2), " seconds."))

	return(
		list(par = psoOut$GBest, val = psoOut$fGBest, 
		     pbest = psoOut$PBest,
		     fpbest = psoOut$fPBest,
		     history = psoOut$fGBestHist, cputime = cputime)
	)
}


#' Generation function of PSO parameter settings
#' 
#' Create a list with PSO parameters for optimal discrimination design search.
#' 
#' @param nSwarm A integer number of swarm size in PSO algorithm.
#' @param maxIter A integer number of maximal PSO iterations.
#' @param checkConv A logical value which controls whether PSO checks the stopping criterion during updating procedure.
#' Specify \code{TRUE} for PSO to compute the stopping criterion \eqn{|f'-f|<\varepsilon}
#' where \eqn{f'} and \eqn{f} are the objective function values in the previous and current iterations, respectively.
#' The default is \code{FALSE}.
#' @param freeRun A number between \eqn{[0,1]} that controls the percentage of PSO iterations which are free from examining the
#' stopping criterion, \eqn{|f'-f|<\varepsilon}
#' where \eqn{f'} and \eqn{f} are the objective function values in the previous and current iterations, respectively.
#' The default is 1.0 implying the PSO will completely ignore the stopping criterion.
#' Otherwise, the PSO checks the stopping criterion after free iterations.
#' @param tol A small value for the tolerance, \eqn{\varepsilon}, in the stopping criterion.
#' For \code{freeRun} smaller than 1.0, the default is \code{1e-6}. Otherwise, this value would not affect the algorithm.
#' @param psoType string. The type of PSO. This package current supports the following types:
#' \itemize{
#' \item{"basic"}{ Linearly Decreasing Weight PSO (Shi, Y. H.	and Eberhart, R. C., 1998)}
# \item{1}{ GCPSO (van den Bergh, F. and	Engelbrecht, A. P., 2002)}
#' \item{"quantum"}{ Quantum PSO (Sun, J., Feng, B. and Xu, W., 2004)}
# \item{3}{ LcRiPSO (Bonyadi, M. R., Michalewicz, Z., 2014)}
#' }
#' @param c1 The value of cognitive parameter in PSO updating procedure. The default is 2.05.
#' @param c2 The value of social parameter in PSO updating procedure. The default is 2.05.
#' @param w0 The value of starting inertia weight in PSO updating procedure. The default is 1.2.
#' @param w1 The value of ending inertia weight in PSO updating procedure. The default is 0.2.
#' @param w_var A number between \eqn{[0,1]} that controls the percentage of iterations that PSO linearly decreases the inertia weight
#' from \code{w0} to \code{w1}. The default is 0.8.
#' @param vk The value of velocity clamping parameter. The default is 4.
#' @param Q_cen_type The type of the center position in QPSO updating procedure (\code{0}: local attractor, default; \code{1}: mean best).
#' @param Q_a0 The value of starting contraction-expansion (CE) coefficient in QPSO updating procedure. The default is 1.7.
#' @param Q_a1 The value of ending contraction-expansion (CE) coefficient in QPSO updating procedure. The default is 0.7.
#' @param Q_a_var A number between \eqn{[0,1]} that controls the percentage of iterations that QPSO linearly decreases the CE coefficient
#' from \code{Q_a0} to \code{Q_a1}. The default is 0.8.
#' @return A list of PSO parameter settings.
#' @examples
#' # Get default settings with specified swarm size and maximal number of iterations.
#' PSO_INFO <- getPSOInfo(nSwarm = 32, maxIter = 100)
#' @name getPSOInfo
#' @rdname getPSOInfo
#' @export
getPSOInfo <- function(nSwarm = 32, maxIter = 100, psoType = "basic",
  #dSwarm = NULL, varUpper = NULL, varLower = NULL, checkConv = 0,
  freeRun = 1.0, tol = 1e-6, c1 = 2.05, c2 = 2.05,
  w0 = 1.2, w1 = 0.2, w_var = 0.8, vk = 4, #, chi = NULL,
  #GC_S_ROOF = 5, GC_F_ROOF = 15, GC_RHO = 1,
  Q_cen_type = 1, Q_a0 = 1.7, Q_a1 = 0.7, Q_a_var = 0.8#, LcRi_L = 0.01,
  ) {

  stopifnot(length(nSwarm) == 1)
  if (!(psoType %in% c("basic", "quantum"))) {
		stop("Currently the function supports: \n
			psoType = 'basic' for basic PSO algorithm.\n
			psoType = 'quantum' for quantum PSO algorithm.")
	} else {
		typePSO <- ifelse(psoType == "basic", 0, 2)
	}

  nLoop <- length(nSwarm)
  #if (length(dSwarm))     dSwarm     <- numeric(nLoop)
  #if (length(varUpper))   varUpper   <- matrix(0, nLoop)
  #if (length(varLower))   varLower   <- matrix(0, nLoop)
  #if (length(maxIter))    maxIter    <- rep(100   , nLoop)
  #if (length(checkConv) < nLoop)  checkConv  <- rep(checkConv, nLoop)
  if (length(typePSO) < nLoop)    typePSO    <- rep(typePSO, nLoop)
  if (length(freeRun) < nLoop)    freeRun    <- rep(freeRun, nLoop)
  if (length(tol) < nLoop)        tol        <- rep(tol, nLoop)
  if (length(c1) < nLoop)         c1         <- rep(c1, nLoop)
  if (length(c2) < nLoop)         c2         <- rep(c2, nLoop)
  if (length(w0) < nLoop)         w0         <- rep(w0, nLoop)
  if (length(w1) < nLoop)         w1         <- rep(w1, nLoop)
  if (length(w_var) < nLoop)      w_var      <- rep(w_var, nLoop)
  #if (length(chi) < nLoop)        chi        <- rep(0.729 , nLoop)
  if (length(vk) < nLoop)         vk         <- rep(vk, nLoop)
  #if (length(GC_S_ROOF) < nLoop)  GC_S_ROOF  <- rep(5     , nLoop)
  #if (length(GC_F_ROOF) < nLoop)  GC_F_ROOF  <- rep(15    , nLoop)
  #if (length(GC_RHO) < nLoop)     GC_RHO     <- rep(1     , nLoop)
  if (length(Q_cen_type) < nLoop) Q_cen_type <- rep(Q_cen_type, nLoop)
  if (length(Q_a0) < nLoop)       Q_a0       <- rep(Q_a0, nLoop)
  if (length(Q_a1) < nLoop)       Q_a1       <- rep(Q_a1, nLoop)
  if (length(Q_a_var) < nLoop)    Q_a_var    <- rep(Q_a_var, nLoop)
  #if (length(LcRi_L) < nLoop)     LcRi_L     <- rep(0.01  , nLoop)

  list(nSwarm = nSwarm, dSwarm = "autogen", varUpper = "autogen", varLower = "autogen", initSwarm = "autogen", 
       hasInitSwarm = "autogen", maxIter = maxIter, 
  	typePSO = typePSO, #checkConv = checkConv,
    freeRun = freeRun, tol = tol, c1 = c1, c2 = c2, w0 = w0, w1 = w1, w_var = w_var, #chi = chi,
    vk = vk,  #GC_S_ROOF = GC_S_ROOF, GC_F_ROOF = GC_F_ROOF,
    #GC_RHO = GC_RHO, 
    Q_cen_type = Q_cen_type, Q_a0 = Q_a0, Q_a1 = Q_a1, Q_a_var = Q_a_var
    #LcRi_L = LcRi_L,
    )
}